%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%%% As of March 2017, [siggraph] is no longer used. Please use sigconf (above) for SIGGRAPH conferences.

%%%% As of May 2020, [sigchi] and [sigchi-a] are no longer used. Please use sigconf (above) for SIGCHI conferences.

%%%% Proceedings format for SIGPLAN conferences 
% \documentclass[sigplan, anonymous, review]{acmart}

%%%% Proceedings format for conferences using one-column small layout
% \documentclass[acmsmall,review]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}
\usepackage{listings}
\usepackage{makecell}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Automated Code Style Enforcement in C Programming Courses}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{Ben Trovato}
%\authornote{Both authors contributed equally to this research.}
%\email{trovato@corporation.com}
%\orcid{1234-5678-9012}
%\author{G.K.M. Tobin}
%\authornotemark[1]
%\email{webmaster@marysville-ohio.com}
%\affiliation{%
%  \institution{Institute for Clarity in Documentation}
%  \streetaddress{P.O. Box 1212}
%  \city{Dublin}
%  \state{Ohio}
%  \postcode{43017-6221}
%}

\author{Rowan Hart}
\affiliation{%
  \institution{Purdue University}
  \city{West Lafayette}
  \state{Indiana}}
\email{hart111@purdue.edu}

\author{Brian Hays}
\affiliation{%
  \institution{Purdue University}
  \city{West Lafayette}
  \state{Indiana}}
  \email{bph412@gmail.com}

\author{Connor McMillin}
\affiliation{%
  \institution{Purdue University}
  \city{West Lafayette}
  \state{Indiana}}
  \email{mcmillinconnor@gmail.com}
  
\author{Dr. Jeffrey A. Turkstra}
\affiliation{%
  \institution{Purdue University}
  \city{West Lafayette}
  \state{Indiana}}
\email{jeff@purdue.edu}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Hart and Turkstra, et. al}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Computer Science students receive significant instruction towards writing functional code.
Auto grading is effective at scale \cite{doi:10.1080/08993400500150747} for the assessment
of student code correctness, however whether code is correct does not necessarily imply
whether code is "good". We propose a standard by which to assess student code style for
the enforcement of programming habits and a C Linter, \textit{Eastwood}, capable of
automatically performing this assessment at scale. Our objective is twofold. First, to
provide a standard of best practices for students to follow while writing code to
complete assignments. Second, to provide a tool to present students with feedback
on demand to minimize the common problem of students treating following a code standard
as an extraneous "busy-work" task instead of an essential part of the software
develpment process. %TODO: add methods and results
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
    <concept>
    <concept_id>10011007.10011006.10011073</concept_id>
    <concept_desc>Software and its engineering~Software maintenance tools</concept_desc>
    <concept_significance>500</concept_significance>
    </concept>
    <concept>
    <concept_id>10010405.10010489.10010490</concept_id>
    <concept_desc>Applied computing~Computer-assisted instruction</concept_desc>
    <concept_significance>500</concept_significance>
    </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Software maintenance tools}
\ccsdesc[500]{Applied computing~Computer-assisted instruction}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{code style, linting, c language, computer science education, automated assessment tools, automated feedback}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
The Computer Science curriculum at the authors' university includes core classes which
consist, with few exceptions, of courses primarily taught using the C programming
language. These courses are generally large, up to several hundred students at a time,
and make liberal use of auto-graders, including custom solutions as well as platforms
such as Vocareum as class sizes increase, a trend that shows no signs of slowing
\cite{10.1145/2839509.2844616}. Unlike automated grading for functionality of student
code, professors implement style standards for student code as they see fit on a
per-course basis, some with as little as a simple visual check by teaching assistants
during grading. Some courses do not check student code for style at all. Some courses
check student code during sessions with Teaching Assistants, but style is not a graded
component of the course.
\\

We posit instructing students to write code with proper style by adhering to programming
best practice guidelines is a critical part of teaching programming. Ample anecdotal
evidence is available from educators worldwide detailing questionable student choices
when writing code, a fact often attributable to a lack of formal standard for those
students to adhere to. Like learning syntax, language features, and algorithms
programming techniques, learning to program \textit{well}, not simply to write programs
that pass a set of tests, is critical to the development of quality programmers
\cite{10.1145/3297156.3297227} and should be taught and evaluated at a commensurate level 
of rigor.
\\

Producing students with the ability to write clean, safe code in addition to code that
meets functional requirements is beneficial to students and the reputation of the
institution. Industry and open source giants such as Google \cite{GoogleCStyleGuide},
LLVM \cite{LLVMStyleGuide}, and Gnome \cite{GnomeStyleGuide} implement style and practice
guidelines for programming and expect employees to adhere to them. It is prudent, then,
to instruct and evaluate students in a similar manner to prepare them to make positive,
usable contributions in their careers through meaningful, competent code. We present a
comprehensive coding standard appropriate for new C programmers, as well as tooling for
the scalable application and evaluation of this standard across even large classes.
\\

\section{Related Works}

\subsection{Auto-Graders}

Prior work in the field of automated grading and course scaling is widely available,
with automated systems and auto-graders filling sessions at \textit{SIGCSE} frequently
in the last decade. Commercially available grading systems such as Gradescope
and Vocareum have pushed functionality assessment toward scalability. Ihantola et.
al in 2010 created an overview of recent advancements and developments in automatic
grading of Computer Science coursework \cite{10.1145/1930565.1930480}. This overview
details advancements in learning management, including automatic testing of code
functionality across languages and disciplines. However, this overview shows the
distinct lack of tools specifically targeted at analyzing code style, only mentioning
style once by way of Kirsti Ala-Mutka \cite{doi:10.1080/08993400500150747}, who describes
traditional linter tools such as Lint as well as advanced tools such as Checkstyle.
Critically, Ala-Mutka connects programming style to "reliability, functionality, and
maintainability" \cite{doi:10.1080/08993400500150747}, a connection that appears to have
degraded over time. Of auto-grading and automation papers put forth in SIGCSE in the past
half decade, only a handful mention coding style, and none present a method for
distributing the automated grading of coding style.
\\

\subsection{Compiler Messages}

Compiler messaging is deeply related to coding style. Compilers, as the primary static
analysis tool in use today, have become adept at providing messages related to
uninitialized variables, improper boolean operations, and so forth. LLVM-based compilers
such as clang, have made pioneering strides towards simplifying error messages to enable
programmers to solve complex issues quickly using static analysis
\cite{ClangStaticChecks}. The GNU Compiler Collection has also begun intiatives towards
improving messaging, implementing Fix-It hints that point to specific code locations and
not only display an error, warning, or note but also provide a suggested fix
\cite{GCCFixItHints}. Some fixes provided by these systems can even be applied
automatically, reducing programmer burden significantly and streamlining debugging.
Research has been conducted into the effectiveness of improved, human readable compiler
errors with mixed \cite{10.1145/3017680.3017768} to positive results
\cite{10.1145/2839509.2844584} measured in increased student performance by Pettit et. al
and Becker, respectively. Becker points out that "students often have little experience
to draw on, leaving compiler error messages as their primary guidance on error
correction". This is doubly true in large courses where office hours may be crowded,
reducing the availability of personalized assistance.
\\

\subsection{Style Analysis}

Despite the small quantity of recent code-style focused research, effort has been put
forth in analyzing code style, particularly in languages higher level than C. Moghadam
et. al put forth a system for analyzing code style, however in their work they "refer
not to mechanical coding conventions (indentation, punctuation, naming of variables, and
so on), but to the effective use of programming idioms" \cite{10.1145/2724660.2728672}.
This concept is not entirely unrelated to conventional style, as idiomatic programming
in C in particular is linked to convention, especially with regards to macro and pointer
use. Leite and Blanco present a comparison of human feedback as compared to automatic
feedback \cite{10.1145/3328778.3366921}, however their automated system does not deliver
syntactic feedback, only functionality-related feedback while their human feedback
included syntactic feedback. They uncover a marginal improvement in the coding style of
students who received style feedback. This suggests that as expected, feedback on style
leads to improved style. This is an important observation, if not a novel one, and is
an observation that we seek to directly leverage by making the style feedback provided
by humans in Leite and Blanco's work possible via automated checks, which eliminates or
greatly reduces the need to commit teaching resources to style assistance.
\\ 

Outside of educational environments, programming style receives middling attention.
As previously mentioned, corporations such as Google \cite{GoogleCStyleGuide} and large
open source projects commonly provide and strictly enforce style guides. Google also
maintains a tool called \texttt{cpplint} \cite{cpplint} that automatically checks code
for conformance to their style guide. This tool is a precursor to the set of checks
Google provides for Clang-Tidy, and is in fact very similar to the initial iteration of
\texttt{Eastwood} in implementing a custom parser. Also similarly to \texttt{Eastwood},
cpplint does not automatically fix code, it simply outputs errors. The motivation for
this decision with respect to \texttt{Eastwood} is covered in greater depth in the
Methodology section.
\\

Yang et. al provide a method for using static Abstract Syntax Tree (AST) based methods
for analyzing programming style using a rule set. They focus on Java, however the
methodology is exceedingly similar to that which we have put forth with
\textit{Eastwood}, using AST traversal to analyze code in the same way a compiler would.
In addition, Yang et. al provide studies of running their analyzer on large open source
projects with striking results, uncovering hundreds of style violations. They recommend
future work into developing analyzers for source code and instituting code style
training for developers, a goal we propose a novel solution for here.
\\

\subsection{Linters}

There are myriad existing tools designed to automatically format code, beginning from the
Unix \texttt{indent} utility and evolving into to modern solutions such as Clang-Tidy
checks that automatically fix style violations as they check code.
\\

\section{History}

The computer science department at our university has always had some form or another of
code style requirements and analysis, as mentioned previously. However, for the C
language specifically, a fully-functional automated tool and standard did not exist
until 2019, when the initial version of the \textit{Eastwood} tool was developed and
implemented by two teaching assistants for our university's course "Programming in C",
which all Computer Science students are required to pass to complete a bachelors degree.
\\

[TODO: statement from Jeff on why an automated tool and proper code standard was needed]
\\

[TODO: statement from Brian and Connor (in progress) on the history of the development of Eastwood 1.0]
\\

Despite the success of the initial version of \textit{Eastwood}, students and teaching
assistants observed several critical issues with the platform. Because it was built atop
top of a Flex and Bison based parser for the ANSI C11 standard, the tool was unable to
run on many external libraries, especially libraries employing GNU extensions to the C
language such as GTK-3.0 and Cairo, both of which are used in projects in introductory C
courses and in later courses employing the C language at our university. In addition,
the structure of \textit{Eastwood} as a parser with no attached type or preprocessor
system meant it experienced intermittent failures to resolve types and resorted to
imperfect methods of analyzing code. This was mostly confined to edge cases, in most
cases having little trouble analyzing code submitted by students, however student
feedback and staff experience indicated that a stronger tool would be appreciated.
Rather than add the necessary functionality to the current system, we explored
alternative platforms with a larger feature set we could build atop to accomplish our
goals in a more extensible and maintainable fashion.
\\

After considering several options, we elected to re-implement our current C Code
Standard by converting the rules to Clang-Tidy \cite{ClangTidyChecks} checks.
The wealth of features provided by the LLVM Project via Clang-Tidy facilitated
re-implementation by a single developer and allowed creating a more flexible tool that
could feasibly be modified and extended to accomplish the goals of not only C
programming courses, but C++ and Objective-C programming courses. In addition, the LLVM
project provides interfaces to deeply analyze a program's AST, a feature that can be
leveraged to combine style analysis with functionality checks that provide a more
holistic view of a student's grasp of the language and solution to a problem.
\\

\section{Methodology}

\textit{Eastwood} is based on a code standard developed and used in C language courses,
particularly "Programming in C" and "Systems Programming".
[TODO: insert statements from Jeff about the development and contribution of the code standard here.
I don't know much about its origin/inspiration/anything it was based on].
\\

For each section and subsection, we implemented a Clang-Tidy check that verifies
whether a student's code meets that part of the standard. If a violation is detected,
\textit{Eastwood} gives a warning of the exact violation, the location it occurs, and in
most cases suggests a change to fix the violation. The output includes an arrow
indicating the exact source location or source range range containing the error
(Listing 1). Automatic fixes are not currently enabled, but are supported by the
Clang-Tidy framework and intentionally disabled for our use case. We disable automatic
fixes to bring the students into the code formatting and style process -- in typical
industry or academic software development a format would be applied automatically, but
we believe causing the students to think about their actions and style is helpful to
develop good habits. However, any educator wishing to adopt our framework could
enable automated fixing to allow their students to apply fixes and conform to the course
coding standard mostly automatically. Each of these checks is implemented in a single
C++ source file and corresponding header, and are implemented in a total of ~7000 LOC.
Despite the non-trivial nature of learning the LLVM and Clang-Tidy framework in order to
implement style checks, this is a comparatively small undertaking as compared to
creating a full C language preprocessor, parser, and static analysis system and can be
feasibly extended or modified by other educators seeking to implement their own
standard.
\\

The default checks can be divided into two categories: syntactic checks and usage
checks. Syntactic checks involve purely appearance-related properties of code such as
whether binary operators are surrounded by spaces, whether functions have descriptive
header comments, or line and function length. Usage checks are a level deeper,
determining factors such as whether all variables are initialized at the time they are
declared, checking all null values are appropriately typed, or determining whether an
expression contains multiple assignment sub-expressions. Generally, syntactic checks
utilize the concept of \textit{Matchers} to locate specific nodes in the program AST to
perform checks: for example the check to ensure all binary operators have a space
preceeding and following the operator matches all binary operators, then uses the clang
lexer to obtain tokens around the operator. Usage checks leverage \textit{Matchers} as
well, but tend not to use the clang lexer directly, preferring to utilize structural
checks and AST visitors to check assertions about the code. For example: every variable
declaration is checked to ensure that the declaration is also a definition to enforce
the idea that "Resource Allocation Is Initialization".
\\

These default checks necessarily closely reflect the specific code standard in use for
these C programming courses, however many are easily adaptable to a slightly different
standard, and the framework for creating these rules serves as a model for how such a
tool can be created using modern techniques, languages, and frameworks. \\

These checks primarily leverage the Lexer and Matcher functionality of the LLVM libraries
to locate instances of problem code and report them to the student. This has become a
critical design decision. Rather than utilize the code standard and \textit{Eastwood}
linter solely to grade students, all students are provided access to the linter 
throughout the semester as a binary and trained on its use for self-evaluation.
The objective is twofold. First, our position is that students will develop good coding
habits not by returning to their code after writing it and fixing code standard
mistakes, but by continuously writing code, evaluating coding style, testing
functionality, and repeating the cycle. Second, the intent of the code standard is not
to create a roadblock of tedious work for students but to provide a format that
encourages clean, readable, functional code. By providing a tool to automatically check
much of the standard, we aim to make adherence to this standard less tedious and more
habitual.
\\

\begin{lstlisting}[basicstyle=\tiny,caption={Example of \textit{Eastwood} output, formatted for width}, captionpos=b]
every_error.c:1:1: warning: Corresponding header file include must be first and
have same basename as source file. [eastwood-Rule8aCheck]
#include <other.h>
^
every_error.c:1:10: warning: Local includes must be included with "...", not
angle braces. [eastwood-Rule8gCheck]
note: this fix will not be applied because it overlaps with another fix
every_error.c:3:5: warning: Variable declaration without definition is
forbidden. [eastwood-Rule12bCheck]
int globalval;
    ^
every_error.c:3:5: warning: Global variable 'globalval' doesn't conform to
global naming scheme. [eastwood-Rule1dCheck]
int globalval;
    ^~~~~~~~~~
    g_globalval
every_error.c:5:9: warning: 'H' is not all uppercase, separated by underscores,
and >= 2 characters in length. [eastwood-Rule1cCheck]
#define H 1
        ^
        H
every_error.c:5:11: warning: 'H' initializer is non-string constant and not
surrounded by parentheses. [eastwood-Rule1cCheck]
#define H 1
          ^
          (1)
every_error.c:7:1: warning: All preprocessor directives outside of a function
should be placed at the top of the file after include directives.
[eastwood-Rule3dCheck]
#define goodbye ("goodbye")
^
every_error.c:7:9: warning: 'goodbye' is not all uppercase, separated by
underscores, and >= 2 characters in length. [eastwood-Rule1cCheck]
#define goodbye ("goodbye")
        ^~~~~~~
        GOODBYE
every_error.c:7:17: warning: 'goodbye' initializer is string constant and
surrounded by parentheses. [eastwood-Rule1cCheck]
#define goodbye ("goodbye")
                ^~~~~~~~~~~
                "goodbye"
every_error.c:9:1: warning: Malformed function header comment for function
foo. [eastwood-Rule7aCheck]
/* foo */
^
every_error.c:11:8: warning: No space permitted between function name and
parameter list. [eastwood-Rule3fCheck]
int foo () {
       ^~
every_error.c:12:5: warning: Incorrect indentation level. Expected 2, got 4
[eastwood-Rule4aCheck]
    int looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong;
  ~~^~~~
every_error.c:12:9: warning: Variable declaration without definition is
forbidden. [eastwood-Rule12bCheck]
    int looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong;
        ^
every_error.c:12:82: warning: Line length must be less than 80 characters
[eastwood-Rule2aCheck]
    int looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong;
                                                                               ~~^
every_error.c:14:13: warning: There must be exactly one space between
parenthesis and open brace. [eastwood-Rule3aCheck]
  if (a == 5){
            ^~
every_error.c:15:6: warning: Leading space required. [eastwood-Rule3bCheck]
    a+=3;
     ^
every_error.c:15:8: warning: Trailing space required. [eastwood-Rule3bCheck]
    a+=3;
       ^
every_error.c:17:18: warning: Single space required after ';'. [eastwood-Rule3cCheck]
  for (int i = 0;i<a;i++) { 
                 ^
every_error.c:17:19: warning: Leading space required. [eastwood-Rule3bCheck]
  for (int i = 0;i<a;i++) { 
                  ^
every_error.c:17:20: warning: Trailing space required. [eastwood-Rule3bCheck]
  for (int i = 0;i<a;i++) { 
                   ^
every_error.c:17:22: warning: Single space required after ';'. [eastwood-Rule3cCheck]
  for (int i = 0;i<a;i++) { 
                     ^
every_error.c:17:28: warning: Trailing whitespace. [eastwood-Rule3eCheck]
  for (int i = 0;i<a;i++) { 
                           ^
every_error.c:22:3: warning: Use of goto. [eastwood-Rule11eCheck]
  goto end;
  ^~~~~~~~
every_error.c:34:8: warning: Line-broken parameter is not aligned with first
parameter. Parameters should be aligned in column 9 (got 8). [eastwood-Rule4bCheck]
       char *b) {
       ^
every_error.c:37:4: warning: While statement in a do-while must be on same
line as the closing brace. [eastwood-Rule4cCheck]
  }
   ^
every_error.c:38:27: warning: Comments must appear above code except for else,
case, #defines, or declarations [eastwood-Rule5bCheck]
  while (*(a++) != '\0'); // Bad comment
                          ^~~~~~~~~~~~~~
\end{lstlisting}


[TODO: insert some details about how code standard grading works and how the linter is integrated into that process. This is best written by Jeff].

\section{Metrics and Results}

To gauge student sentiment concerning the helpfulness of both the code standard and
linter, students were asked to voluntarily complete two anonymous surveys, one at the
halfway point and one at the end of the Spring 2021 semester of "Programming in C",
the first course at our University in which students learn to use the C language. As a
foundational course, enrollment is high at approximately 200 students. For first six
weeks of the course, students used the "old" version of \textit{Eastwood} implemented with
a custom parser. For the remainder of the course, students used the "new" version of
\textit{Eastwood} implemented using Clang-Tidy once development of the new version reached
an appropriate stage for widespread use. The surveys collected responses from students
about both the code standard used in the course and \textit{Eastwood}, the linting tool
to automatically check adherence to the standard. Specifically, the survey sought to
determine students takeaways about two factors. First, whether they felt that using the
code standard and linting tool caused them to write better, more readable code with
less bugs. Second, whether they had a positive reaction to the requirement to follow
a coding standard and intended to continue to follow some personal standard in the
future. For tool development reasons, the end of semester survey also asked about
the differece between the "new" Clang-Tidy based linter and the "old" custom parser
based linter. When only one value is discussed for a survey response, the value will
be from the end of semester survey concerning the current "new" linter, as that linter
is the primary contribution of this work.
\\

\begin{table*}[t]
  \centering
  \begin{tabular}{cccccl}
    Strongly Agree & Agree & Neutral & Disagree & Strongly Disagree & Question \\
    \hline
    25.9\% & 57.1\% & 11.6\% & 4.1\%  & 1.4\% & The new linter makes it easier to meet the code standard. \\
    \hline
    33.3\% & 42.9\% & 15.6\% & 6.1\%  & 2\%   & The new linter saves time meeting the code standard. \\
    \hline
    23.1\% & 54.4\% & 15.6\% & 4.8\%  & 2\%   & \makecell{The new linter effectively checks whether my code meets \\ the standard.} \\
    \hline
    33.3\% & 50.3\% & 12.2\% & 2.7\%  & 2.7\% & \makecell{The new linter helps me accurately locate code standard \\ violations in my code.} \\
    \hline
    19.7\% & 47.6\% & 28.6\% & 3.4\%  & 0.7\% & The new linter helps improve the quality of my code. \\
    \hline
    8.3\%  & 31\%   & 32.4\% & 22.8\% & 5.5\% & The new linter helps me find bugs in my code. \\
    \hline
    23.1\% & 50.3\% & 17.7\% & 6.8\%  & 2\%   & The new linter helps me make my code more readable. \\
    \hline
    15.8\% & 48.6\% & 19.2\% & 11.6\% & 4.8\% & Following the code standard improves my code quality. \\
    \hline
    14.4\% & 38.4\% & 24\% & 16.6\% & 6.8\% & \makecell{I will continue to use the...Code Standard in \\ future C programming...} \\
    \hline
    21.9\% & 49.3\% & 13.7\% & 5.5\% & 9.6\% & \makecell{I will continue to use some code standard in \\ future C programming...} \\
    \hline
  \end{tabular}
  \caption{Results of Student Survey}
\end{table*}

As demonstrated by the results of the student survey regarding the linting tool and code
standard, student opinion is generally very positive. This indicates that despite
the fact that requiring adherence to a standard could be perceived as "busy work" or not
a direct contribution to writing code that passes test cases and earns a good score for
functionality, students understand the value writing well structured and formatted
code represents.
\\

More than 80\% of students reported agreement that \textit{Eastwood} makes 
it easier to follow the meet the existing code standard. This means the tool accomplishes
its primary goal, as the code standard has always been a component of the course grade.
Likewise, over 75\% of students reported that the linter saves time meeting the code
standard. This means the linter has certainly accomplished a secondary goal of reducing
the tedium required to help their code conform to the standard. Anecdotal evidence from
observing students during lab meetings suggests that because the linter is able to quickly
check code, students use it continually while they work instead of waiting until the end
to fix all formatting errors. We find this very meaningful, as it suggests students are
integrating style and formatting into their workflow, a habit we have designed the code
standard and linting tool to facilitate.
\\

The next two questions, whether the linter "effectively checks whether my code meets the
standard" (77.5\% agreement) and whether the linter "helps me accurately locate code 
standard violations..." (83.6\% agreement) sought to understand how \textbf{well}
\textit{Eastwood} was able to perform its checks. Once again, the highly positive responses
suggest that the tool works accurately and correctly in helping students meet the set
standard.
\\

The next three questions were the least specific, but attempted to discern whether
students felt that \textit{Eastwood} helped students write "better" code by asking about
three distinct areas. First, we asked about "quality" without giving a definition of
"quality", thereby leaving students to answer subjectively. 67.3\% of students agreed
or strongly agreed that \textit{Eastwood} helped them write higher quality code, a result
we feel is very indicative of how simple guidelines and tools to help students painlessly
follow them can improve habits and results. Unsurprisingly, less than 40\% of students
agreed that \textit{Eastwood} helped them find bugs in their code. Finding bugs is not a
goal of \textit{Eastwood} and in fact there are zero rules built into the tool
that detect the definite presence of a programming error. That even 40\% of students
agreed with this statement then, is extremely interesting. We suspect that by writing
better formatted and well-styled code, students were more easily able to \textit{find
bugs themselves}, a deeper and even more encouraging result than anticipated. This is
difficult to quantitatively ascertain, but from anecdotal discussions with students
we believe this is the case. Finally, nearly 75\% of students felt \textit{Eastwood}
helped make their code more readable.
\\

Finally, we asked questions regarding the code standard itself, instead of about the
\textit{Eastwood} linter. Anecdotally, students find some of the points in the code
standard enforced in our course unnecessary or reflective of older K\&R C programming
guidelines. Thus, it was unsurprising that only 52\% of students agreed that they would
use the code standard from this course in furure C programming. The over 70\%
of students who agree that they will continue to use some code standard, not necessarily
the standard used in this particular course, in the future is a strong positive result.
This demonstrates that overall, students have seen the value of having some standard to
hold themselves to and more importantly, intend to continue to do so of their own
volition.
\\



Overall, the results of this survey suggest to us that \textit{Eastwood} is effective in
meeting its primary goal of helping students more easily meet the course code standard
we have set. We also observed a positive indication that students both understand and
value the role of code style, consistency, and formatting in the software development
process.
\\

\section{Conclusions and Future Work}

We propose two ideas concerning assessment of student code projects in Computer Science.
First, we recommend that programming courses adopt a code style and best practices
standard for code formatting, organization, and syntax in addition to language-specific
best practices. We base this recommendation on previously referenced statements by
Ala-Mutka and Yang, both of whom present information suggesting a tangible association
between code style and overall code quality. Second, we recommend that in adopting a
code style guide, automated tooling such as the \textit{Eastwood} linter be utilized to
the fullest possible extent to provide the best experience for staff and students.
Courses typically have only a few Graduate Teaching Assistants and several Undergraduate
Teaching Assistants. As put forth by Dickson, Dragon, and Lee
\cite{10.1145/3017680.3017725} it is feasible to delegate grading of code standard
adherence to Undergraduates, however doing so is not an effective use of time,
especially when automated grading systems are available and possible. 

We put forth \textit{Eastwood}, one such example of an end to end solution that provides
instant, feedback and suggestions to students. Such a system helps encourage good 
programming habits that will ideally stay with students as they continue in their 
careers. It also reduces the workload on students and course staff in the software
development and grading processes, respectively.
\\

There is ample future work in this area. Defining code standards is a somewhat
subjective matter, and implementing automated checks for those standardized
requirements will provide a continuous engineering challenge. Improved static analysis
techniques would allow a code standard to check for functionality errors that may not be
observed by simple output-based automated test systems such as Vocareum employed heavily 
by university programs. In summation: code style is an exciting opportunity to reinforce
student skills that are at present largely left by the wayside.
\\

\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}

\end{document}
\endinput
